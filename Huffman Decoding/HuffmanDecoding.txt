("This code is contributed by Riyazul555")

// Time Complexity: O(N log N)  N is the size of the input file
// Space Complexity: O(N)       N is the size of the input file

// Include necessary libraries
#include_library <fstream>
#include_library <queue>
#include_library <cstring>
#include_library <algorithm>
#include_library <map>

// Define constant for maximum number of elements
define nMax 20005

// Function to perform Depth-First Search (DFS)
function dfs(nod, val, G, cod) {
    if G[nod][0] == -1 {
        cod[nod] = val
        return
    }
    dfs(G[nod][0], val+"0", G, cod)
    dfs(G[nod][1], val+"1", G, cod)
}

// Main function
function main(argc, argv[]) {
    // Open input file
    ifstream fin(argv[1]);
    // Open output file
    ofstream fout(argv[2]);

    // Declare variables
    int n, fr[nMax], val[nMax];

    // Read number of characters from input
    fin >> n;
    fin.get();

    // Vector to store characters
    vector<char> v;
    // Priority queue to store characters based on frequency and value
    auto compare = [&fr, &val](a, b) { return ((fr[a] > fr[b])  || (fr[a]==fr[b] && val[a]>val[b])); };
    priority_queue<int, vector<int>, decltype(compare)> Q(compare);

    // Read characters and frequencies, and initialize priority queue
    for (int i = 0; i < n; i++) {
        char ch;
        fin.get(ch);
        v.push_back(ch);
        fin >> fr[i];
        val[i] = i;
        Q.push(i);
        fin.get();
    }

    // Initialize 2D array to store Huffman tree
    int G[nMax][2];
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < nMax; j++) {
            G[j][i] = -1;
        }
    }

    // Build Huffman tree
    int z = n - 1;
    while (Q.size() > 1) {
        int x = Q.top();
        Q.pop();
        int y = Q.top();
        Q.pop();
        z++;
        fr[z] = fr[x] + fr[y];
        val[z] = min(val[x], val[y]);
        Q.push(z);
        G[z][0] = x;
        G[z][1] = y;
    }

    // Generate codewords using DFS
    string cod[nMax];
    dfs(z, "", G, cod);

    // Read input string and decode using Huffman codes
    string s1, s2 = "";
    getline(fin, s1);
    for (int i = 0; i < s1.size(); i++) {
        s2 += s1[i];
        bool ok = 0;
        for (int j = 0; j < v.size() && !ok; j++) {
            if (s2 == cod[j]) {
                fout << v[j];
                s2 = "";
                ok = 1;
            }
        }
    }

    return 0;
}
